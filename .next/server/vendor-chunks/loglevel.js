"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/loglevel";
exports.ids = ["vendor-chunks/loglevel"];
exports.modules = {

/***/ "(ssr)/./node_modules/loglevel/lib/loglevel.js":
/*!***********************************************!*\
  !*** ./node_modules/loglevel/lib/loglevel.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/ (function(root, definition) {\n    \"use strict\";\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(void 0, function() {\n    \"use strict\";\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = \"undefined\" !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n    var _loggersByName = {};\n    var defaultLogger = null;\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === \"function\") {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [\n                        obj,\n                        arguments\n                    ]);\n                };\n            }\n        }\n    }\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [\n                    console,\n                    arguments\n                ]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === \"debug\") {\n            methodName = \"log\";\n        }\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === \"trace\" && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, \"log\");\n        } else {\n            return noop;\n        }\n    }\n    // These private functions always need `this` to be set properly\n    function replaceLoggingMethods() {\n        /*jshint validthis:true */ var level = this.getLevel();\n        // Replace the actual methods.\n        for(var i = 0; i < logMethods.length; i++){\n            var methodName = logMethods[i];\n            this[methodName] = i < level ? noop : this.methodFactory(methodName, level, this.name);\n        }\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n        // Return any important warnings.\n        if (typeof console === undefinedType && level < this.levels.SILENT) {\n            return \"No console available for logging\";\n        }\n    }\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName) {\n        return function() {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, _level, _loggerName) {\n        /*jshint validthis:true */ return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n    function Logger(name, factory) {\n        // Private instance variables.\n        var self = this;\n        /**\n       * The level inherited from a parent logger (or a global default). We\n       * cache this here rather than delegating to the parent so that it stays\n       * in sync with the actual logging methods that we have installed (the\n       * parent could change levels but we might not have rebuilt the loggers\n       * in this child yet).\n       * @type {number}\n       */ var inheritedLevel;\n        /**\n       * The default level for this logger, if any. If set, this overrides\n       * `inheritedLevel`.\n       * @type {number|null}\n       */ var defaultLevel;\n        /**\n       * A user-specific level for this logger. If set, this overrides\n       * `defaultLevel`.\n       * @type {number|null}\n       */ var userLevel;\n        var storageKey = \"loglevel\";\n        if (typeof name === \"string\") {\n            storageKey += \":\" + name;\n        } else if (typeof name === \"symbol\") {\n            storageKey = undefined;\n        }\n        function persistLevelIfPossible(levelNum) {\n            var levelName = (logMethods[levelNum] || \"silent\").toUpperCase();\n            if (\"undefined\" === undefinedType || !storageKey) return;\n            // Use localStorage if available\n            try {\n                window.localStorage[storageKey] = levelName;\n                return;\n            } catch (ignore) {}\n            // Use session cookie as fallback\n            try {\n                window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n            } catch (ignore) {}\n        }\n        function getPersistedLevel() {\n            var storedLevel;\n            if (\"undefined\" === undefinedType || !storageKey) return;\n            try {\n                storedLevel = window.localStorage[storageKey];\n            } catch (ignore) {}\n            // Fallback to cookies if local storage gives us nothing\n            if (typeof storedLevel === undefinedType) {\n                try {\n                    var cookie = window.document.cookie;\n                    var cookieName = encodeURIComponent(storageKey);\n                    var location = cookie.indexOf(cookieName + \"=\");\n                    if (location !== -1) {\n                        storedLevel = /^([^;]+)/.exec(cookie.slice(location + cookieName.length + 1))[1];\n                    }\n                } catch (ignore) {}\n            }\n            // If the stored level is not valid, treat it as if nothing was stored.\n            if (self.levels[storedLevel] === undefined) {\n                storedLevel = undefined;\n            }\n            return storedLevel;\n        }\n        function clearPersistedLevel() {\n            if (\"undefined\" === undefinedType || !storageKey) return;\n            // Use localStorage if available\n            try {\n                window.localStorage.removeItem(storageKey);\n            } catch (ignore) {}\n            // Use session cookie as fallback\n            try {\n                window.document.cookie = encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n            } catch (ignore) {}\n        }\n        function normalizeLevel(input) {\n            var level = input;\n            if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n                level = self.levels[level.toUpperCase()];\n            }\n            if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n                return level;\n            } else {\n                throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\n            }\n        }\n        /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */ self.name = name;\n        self.levels = {\n            \"TRACE\": 0,\n            \"DEBUG\": 1,\n            \"INFO\": 2,\n            \"WARN\": 3,\n            \"ERROR\": 4,\n            \"SILENT\": 5\n        };\n        self.methodFactory = factory || defaultMethodFactory;\n        self.getLevel = function() {\n            if (userLevel != null) {\n                return userLevel;\n            } else if (defaultLevel != null) {\n                return defaultLevel;\n            } else {\n                return inheritedLevel;\n            }\n        };\n        self.setLevel = function(level, persist) {\n            userLevel = normalizeLevel(level);\n            if (persist !== false) {\n                persistLevelIfPossible(userLevel);\n            }\n            // NOTE: in v2, this should call rebuild(), which updates children.\n            return replaceLoggingMethods.call(self);\n        };\n        self.setDefaultLevel = function(level) {\n            defaultLevel = normalizeLevel(level);\n            if (!getPersistedLevel()) {\n                self.setLevel(level, false);\n            }\n        };\n        self.resetLevel = function() {\n            userLevel = null;\n            clearPersistedLevel();\n            replaceLoggingMethods.call(self);\n        };\n        self.enableAll = function(persist) {\n            self.setLevel(self.levels.TRACE, persist);\n        };\n        self.disableAll = function(persist) {\n            self.setLevel(self.levels.SILENT, persist);\n        };\n        self.rebuild = function() {\n            if (defaultLogger !== self) {\n                inheritedLevel = normalizeLevel(defaultLogger.getLevel());\n            }\n            replaceLoggingMethods.call(self);\n            if (defaultLogger === self) {\n                for(var childName in _loggersByName){\n                    _loggersByName[childName].rebuild();\n                }\n            }\n        };\n        // Initialize all the internal levels.\n        inheritedLevel = normalizeLevel(defaultLogger ? defaultLogger.getLevel() : \"WARN\");\n        var initialLevel = getPersistedLevel();\n        if (initialLevel != null) {\n            userLevel = normalizeLevel(initialLevel);\n        }\n        replaceLoggingMethods.call(self);\n    }\n    /*\n     *\n     * Top-level API\n     *\n     */ defaultLogger = new Logger();\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\n            throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n        var logger = _loggersByName[name];\n        if (!logger) {\n            logger = _loggersByName[name] = new Logger(name, defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n    // Grab the current global log variable in case of overwrite\n    var _log = \"undefined\" !== undefinedType ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (\"undefined\" !== undefinedType && window.log === defaultLogger) {\n            window.log = _log;\n        }\n        return defaultLogger;\n    };\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n    // ES6 default export, for compatibility\n    defaultLogger[\"default\"] = defaultLogger;\n    return defaultLogger;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7QUFLQSxHQUNDLFVBQVVBLElBQUksRUFBRUMsVUFBVTtJQUN2QjtJQUNBLElBQUksSUFBMEMsRUFBRTtRQUM1Q0Msb0NBQU9ELFVBQVVBO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0dBQUNBO0lBQ3RCLE9BQU8sRUFJTjtBQUNMLEdBQUUsUUFBTTtJQUNKO0lBRUEsMERBQTBEO0lBQzFELElBQUlNLE9BQU8sWUFBWTtJQUN2QixJQUFJQyxnQkFBZ0I7SUFDcEIsSUFBSUMsT0FBTyxnQkFBbUJELGlCQUFtQixPQUFPRSxPQUFPQyxTQUFTLEtBQUtILGlCQUN6RSxrQkFBa0JJLElBQUksQ0FBQ0YsT0FBT0MsU0FBUyxDQUFDRSxTQUFTO0lBR3JELElBQUlDLGFBQWE7UUFDYjtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFFRCxJQUFJQyxpQkFBaUIsQ0FBQztJQUN0QixJQUFJQyxnQkFBZ0I7SUFFcEIsZ0VBQWdFO0lBQ2hFLFNBQVNDLFdBQVdDLEdBQUcsRUFBRUMsVUFBVTtRQUMvQixJQUFJQyxTQUFTRixHQUFHLENBQUNDLFdBQVc7UUFDNUIsSUFBSSxPQUFPQyxPQUFPQyxJQUFJLEtBQUssWUFBWTtZQUNuQyxPQUFPRCxPQUFPQyxJQUFJLENBQUNIO1FBQ3ZCLE9BQU87WUFDSCxJQUFJO2dCQUNBLE9BQU9JLFNBQVNDLFNBQVMsQ0FBQ0YsSUFBSSxDQUFDRyxJQUFJLENBQUNKLFFBQVFGO1lBQ2hELEVBQUUsT0FBT08sR0FBRztnQkFDUiw2REFBNkQ7Z0JBQzdELE9BQU87b0JBQ0gsT0FBT0gsU0FBU0MsU0FBUyxDQUFDRyxLQUFLLENBQUNBLEtBQUssQ0FBQ04sUUFBUTt3QkFBQ0Y7d0JBQUtTO3FCQUFVO2dCQUNsRTtZQUNKO1FBQ0o7SUFDSjtJQUVBLCtFQUErRTtJQUMvRSxTQUFTQztRQUNMLElBQUlDLFFBQVF2QixHQUFHLEVBQUU7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Y0FBYyxDQUFDd0IsS0FBSztRQUNqQyxJQUFJLENBQUMrQyxRQUFRO1lBQ1RBLFNBQVN2RSxjQUFjLENBQUN3QixLQUFLLEdBQUcsSUFBSVEsT0FDaENSLE1BQ0F2QixjQUFjc0IsYUFBYTtRQUVuQztRQUNBLE9BQU9nRDtJQUNYO0lBRUEsNERBQTREO0lBQzVELElBQUlDLE9BQU8sZ0JBQW1CL0UsZ0JBQWlCRSxPQUFPSixHQUFHLEdBQUcwQjtJQUM1RGhCLGNBQWN3RSxVQUFVLEdBQUc7UUFDdkIsSUFBSSxnQkFBa0JoRixpQkFDZkUsT0FBT0osR0FBRyxLQUFLVSxlQUFlO1lBQ2pDTixPQUFPSixHQUFHLEdBQUdpRjtRQUNqQjtRQUVBLE9BQU92RTtJQUNYO0lBRUFBLGNBQWN5RSxVQUFVLEdBQUcsU0FBU0E7UUFDaEMsT0FBTzFFO0lBQ1g7SUFFQSx3Q0FBd0M7SUFDeENDLGFBQWEsQ0FBQyxVQUFVLEdBQUdBO0lBRTNCLE9BQU9BO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9idXR0ZXJmbHktcHJlc2FsZS8uL25vZGVfbW9kdWxlcy9sb2dsZXZlbC9saWIvbG9nbGV2ZWwuanM/Njg2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiovXG4oZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxuICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XG4gICAgdmFyIGlzSUUgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgJiYgKHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yICE9PSB1bmRlZmluZWRUeXBlKSAmJiAoXG4gICAgICAgIC9UcmlkZW50XFwvfE1TSUUgLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KVxuICAgICk7XG5cbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcbiAgICAgICAgXCJ0cmFjZVwiLFxuICAgICAgICBcImRlYnVnXCIsXG4gICAgICAgIFwiaW5mb1wiLFxuICAgICAgICBcIndhcm5cIixcbiAgICAgICAgXCJlcnJvclwiXG4gICAgXTtcblxuICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xuICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbnVsbDtcblxuICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHJhY2UoKSBkb2Vzbid0IHByaW50IHRoZSBtZXNzYWdlIGluIElFLCBzbyBmb3IgdGhhdCBjYXNlIHdlIG5lZWQgdG8gd3JhcCBpdFxuICAgIGZ1bmN0aW9uIHRyYWNlRm9ySUUoKSB7XG4gICAgICAgIGlmIChjb25zb2xlLmxvZykge1xuICAgICAgICAgICAgaWYgKGNvbnNvbGUubG9nLmFwcGx5KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gb2xkIElFLCBuYXRpdmUgY29uc29sZSBtZXRob2RzIHRoZW1zZWx2ZXMgZG9uJ3QgaGF2ZSBhcHBseSgpLlxuICAgICAgICAgICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShjb25zb2xlLmxvZywgW2NvbnNvbGUsIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zb2xlLnRyYWNlKSBjb25zb2xlLnRyYWNlKCk7XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52XG4gICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlc1xuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZE5hbWUgPT09ICd0cmFjZScgJiYgaXNJRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNlRm9ySUU7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcygpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy5nZXRMZXZlbCgpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIGFjdHVhbCBtZXRob2RzLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSAoaSA8IGxldmVsKSA/XG4gICAgICAgICAgICAgICAgbm9vcCA6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCB0aGlzLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIGxvZy5sb2cgYXMgYW4gYWxpYXMgZm9yIGxvZy5kZWJ1Z1xuICAgICAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7XG5cbiAgICAgICAgLy8gUmV0dXJuIGFueSBpbXBvcnRhbnQgd2FybmluZ3MuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHRoaXMubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC5cbiAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBfbGV2ZWwsIF9sb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XG4gICAgICAgICAgICAgICBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGZhY3RvcnkpIHtcbiAgICAgIC8vIFByaXZhdGUgaW5zdGFuY2UgdmFyaWFibGVzLlxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbGV2ZWwgaW5oZXJpdGVkIGZyb20gYSBwYXJlbnQgbG9nZ2VyIChvciBhIGdsb2JhbCBkZWZhdWx0KS4gV2VcbiAgICAgICAqIGNhY2hlIHRoaXMgaGVyZSByYXRoZXIgdGhhbiBkZWxlZ2F0aW5nIHRvIHRoZSBwYXJlbnQgc28gdGhhdCBpdCBzdGF5c1xuICAgICAgICogaW4gc3luYyB3aXRoIHRoZSBhY3R1YWwgbG9nZ2luZyBtZXRob2RzIHRoYXQgd2UgaGF2ZSBpbnN0YWxsZWQgKHRoZVxuICAgICAgICogcGFyZW50IGNvdWxkIGNoYW5nZSBsZXZlbHMgYnV0IHdlIG1pZ2h0IG5vdCBoYXZlIHJlYnVpbHQgdGhlIGxvZ2dlcnNcbiAgICAgICAqIGluIHRoaXMgY2hpbGQgeWV0KS5cbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHZhciBpbmhlcml0ZWRMZXZlbDtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGRlZmF1bHQgbGV2ZWwgZm9yIHRoaXMgbG9nZ2VyLCBpZiBhbnkuIElmIHNldCwgdGhpcyBvdmVycmlkZXNcbiAgICAgICAqIGBpbmhlcml0ZWRMZXZlbGAuXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfG51bGx9XG4gICAgICAgKi9cbiAgICAgIHZhciBkZWZhdWx0TGV2ZWw7XG4gICAgICAvKipcbiAgICAgICAqIEEgdXNlci1zcGVjaWZpYyBsZXZlbCBmb3IgdGhpcyBsb2dnZXIuIElmIHNldCwgdGhpcyBvdmVycmlkZXNcbiAgICAgICAqIGBkZWZhdWx0TGV2ZWxgLlxuICAgICAgICogQHR5cGUge251bWJlcnxudWxsfVxuICAgICAgICovXG4gICAgICB2YXIgdXNlckxldmVsO1xuXG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgc3RvcmFnZUtleSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xuICAgICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIHZhciBzdG9yZWRMZXZlbDtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcbiAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcbiAgICAgICAgICAgICAgICAgIHZhciBjb29raWVOYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoY29va2llTmFtZSArIFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2llLnNsaWNlKGxvY2F0aW9uICsgY29va2llTmFtZS5sZW5ndGggKyAxKVxuICAgICAgICAgICAgICAgICAgICAgIClbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNsZWFyUGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JhZ2VLZXkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPTsgZXhwaXJlcz1UaHUsIDAxIEphbiAxOTcwIDAwOjAwOjAwIFVUQ1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbm9ybWFsaXplTGV2ZWwoaW5wdXQpIHtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSBpbnB1dDtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICByZXR1cm4gbGV2ZWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgaW5wdXQpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAqXG4gICAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHNcbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgc2VsZi5uYW1lID0gbmFtZTtcblxuICAgICAgc2VsZi5sZXZlbHMgPSB7IFwiVFJBQ0VcIjogMCwgXCJERUJVR1wiOiAxLCBcIklORk9cIjogMiwgXCJXQVJOXCI6IDMsXG4gICAgICAgICAgXCJFUlJPUlwiOiA0LCBcIlNJTEVOVFwiOiA1fTtcblxuICAgICAgc2VsZi5tZXRob2RGYWN0b3J5ID0gZmFjdG9yeSB8fCBkZWZhdWx0TWV0aG9kRmFjdG9yeTtcblxuICAgICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodXNlckxldmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VyTGV2ZWw7XG4gICAgICAgICAgfSBlbHNlIGlmIChkZWZhdWx0TGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRMZXZlbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluaGVyaXRlZExldmVsO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICB1c2VyTGV2ZWwgPSBub3JtYWxpemVMZXZlbChsZXZlbCk7XG4gICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgIHBlcnNpc3RMZXZlbElmUG9zc2libGUodXNlckxldmVsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBOT1RFOiBpbiB2MiwgdGhpcyBzaG91bGQgY2FsbCByZWJ1aWxkKCksIHdoaWNoIHVwZGF0ZXMgY2hpbGRyZW4uXG4gICAgICAgICAgcmV0dXJuIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBkZWZhdWx0TGV2ZWwgPSBub3JtYWxpemVMZXZlbChsZXZlbCk7XG4gICAgICAgICAgaWYgKCFnZXRQZXJzaXN0ZWRMZXZlbCgpKSB7XG4gICAgICAgICAgICAgIHNlbGYuc2V0TGV2ZWwobGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnJlc2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdXNlckxldmVsID0gbnVsbDtcbiAgICAgICAgICBjbGVhclBlcnNpc3RlZExldmVsKCk7XG4gICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZik7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFLCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnJlYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGRlZmF1bHRMb2dnZXIgIT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgaW5oZXJpdGVkTGV2ZWwgPSBub3JtYWxpemVMZXZlbChkZWZhdWx0TG9nZ2VyLmdldExldmVsKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmKTtcblxuICAgICAgICAgIGlmIChkZWZhdWx0TG9nZ2VyID09PSBzZWxmKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGNoaWxkTmFtZSBpbiBfbG9nZ2Vyc0J5TmFtZSkge1xuICAgICAgICAgICAgICAgIF9sb2dnZXJzQnlOYW1lW2NoaWxkTmFtZV0ucmVidWlsZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBhbGwgdGhlIGludGVybmFsIGxldmVscy5cbiAgICAgIGluaGVyaXRlZExldmVsID0gbm9ybWFsaXplTGV2ZWwoXG4gICAgICAgICAgZGVmYXVsdExvZ2dlciA/IGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSA6IFwiV0FSTlwiXG4gICAgICApO1xuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsICE9IG51bGwpIHtcbiAgICAgICAgICB1c2VyTGV2ZWwgPSBub3JtYWxpemVMZXZlbChpbml0aWFsTGV2ZWwpO1xuICAgICAgfVxuICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZik7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKlxuICAgICAqIFRvcC1sZXZlbCBBUElcbiAgICAgKlxuICAgICAqL1xuXG4gICAgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICAgICAgaWYgKCh0eXBlb2YgbmFtZSAhPT0gXCJzeW1ib2xcIiAmJiB0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikgfHwgbmFtZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIoXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgdmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xuICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxuICAgICAgICAgICAgICAgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikge1xuICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICB9O1xuXG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHtcbiAgICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lO1xuICAgIH07XG5cbiAgICAvLyBFUzYgZGVmYXVsdCBleHBvcnQsIGZvciBjb21wYXRpYmlsaXR5XG4gICAgZGVmYXVsdExvZ2dlclsnZGVmYXVsdCddID0gZGVmYXVsdExvZ2dlcjtcblxuICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xufSkpO1xuIl0sIm5hbWVzIjpbInJvb3QiLCJkZWZpbml0aW9uIiwiZGVmaW5lIiwiYW1kIiwibW9kdWxlIiwiZXhwb3J0cyIsImxvZyIsIm5vb3AiLCJ1bmRlZmluZWRUeXBlIiwiaXNJRSIsIndpbmRvdyIsIm5hdmlnYXRvciIsInRlc3QiLCJ1c2VyQWdlbnQiLCJsb2dNZXRob2RzIiwiX2xvZ2dlcnNCeU5hbWUiLCJkZWZhdWx0TG9nZ2VyIiwiYmluZE1ldGhvZCIsIm9iaiIsIm1ldGhvZE5hbWUiLCJtZXRob2QiLCJiaW5kIiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJjYWxsIiwiZSIsImFwcGx5IiwiYXJndW1lbnRzIiwidHJhY2VGb3JJRSIsImNvbnNvbGUiLCJ0cmFjZSIsInJlYWxNZXRob2QiLCJ1bmRlZmluZWQiLCJyZXBsYWNlTG9nZ2luZ01ldGhvZHMiLCJsZXZlbCIsImdldExldmVsIiwiaSIsImxlbmd0aCIsIm1ldGhvZEZhY3RvcnkiLCJuYW1lIiwiZGVidWciLCJsZXZlbHMiLCJTSUxFTlQiLCJlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzIiwiZGVmYXVsdE1ldGhvZEZhY3RvcnkiLCJfbGV2ZWwiLCJfbG9nZ2VyTmFtZSIsIkxvZ2dlciIsImZhY3RvcnkiLCJzZWxmIiwiaW5oZXJpdGVkTGV2ZWwiLCJkZWZhdWx0TGV2ZWwiLCJ1c2VyTGV2ZWwiLCJzdG9yYWdlS2V5IiwicGVyc2lzdExldmVsSWZQb3NzaWJsZSIsImxldmVsTnVtIiwibGV2ZWxOYW1lIiwidG9VcHBlckNhc2UiLCJsb2NhbFN0b3JhZ2UiLCJpZ25vcmUiLCJkb2N1bWVudCIsImNvb2tpZSIsImVuY29kZVVSSUNvbXBvbmVudCIsImdldFBlcnNpc3RlZExldmVsIiwic3RvcmVkTGV2ZWwiLCJjb29raWVOYW1lIiwibG9jYXRpb24iLCJpbmRleE9mIiwiZXhlYyIsInNsaWNlIiwiY2xlYXJQZXJzaXN0ZWRMZXZlbCIsInJlbW92ZUl0ZW0iLCJub3JtYWxpemVMZXZlbCIsImlucHV0IiwiVHlwZUVycm9yIiwic2V0TGV2ZWwiLCJwZXJzaXN0Iiwic2V0RGVmYXVsdExldmVsIiwicmVzZXRMZXZlbCIsImVuYWJsZUFsbCIsIlRSQUNFIiwiZGlzYWJsZUFsbCIsInJlYnVpbGQiLCJjaGlsZE5hbWUiLCJpbml0aWFsTGV2ZWwiLCJnZXRMb2dnZXIiLCJsb2dnZXIiLCJfbG9nIiwibm9Db25mbGljdCIsImdldExvZ2dlcnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/loglevel/lib/loglevel.js\n");

/***/ })

};
;